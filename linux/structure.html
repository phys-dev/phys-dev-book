<!DOCTYPE HTML>
<html lang="ru" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Внутреннее устройство Linux - Разработка и применение программного обеспечения в физических исследованиях</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../intro/intro.html">О книге</a></li><li class="chapter-item expanded affix "><a href="../intro/about-me.html">О себе</a></li><li class="chapter-item expanded affix "><li class="part-title">Ищем помощников</li><li class="chapter-item expanded "><a href="../ai/intro.html"><strong aria-hidden="true">1.</strong> ИИ для разработки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ai/context.html"><strong aria-hidden="true">1.1.</strong> Контекст и скорость изменений</a></li><li class="chapter-item expanded "><a href="../ai/develop.html"><strong aria-hidden="true">1.2.</strong> ИИ и разработчик</a></li><li class="chapter-item expanded "><a href="../ai/basic.html"><strong aria-hidden="true">1.3.</strong> Технические основы</a></li><li class="chapter-item expanded "><a href="../ai/instruments.html"><strong aria-hidden="true">1.4.</strong> Инструментарий</a></li><li class="chapter-item expanded "><a href="../ai/qa.html"><strong aria-hidden="true">1.5.</strong> Вопросы и ответы</a></li></ol></li><li class="chapter-item expanded "><a href="../dev/python/intro.html"><strong aria-hidden="true">2.</strong> Python</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../dev/python/basics.html"><strong aria-hidden="true">2.1.</strong> Basics</a></li><li class="chapter-item expanded "><a href="../dev/python/numpy.html"><strong aria-hidden="true">2.2.</strong> Numpy</a></li><li class="chapter-item expanded "><a href="../dev/python/scipy.html"><strong aria-hidden="true">2.3.</strong> Scipy</a></li><li class="chapter-item expanded "><a href="../dev/python/matplotlib.html"><strong aria-hidden="true">2.4.</strong> Matplotlib</a></li><li class="chapter-item expanded "><a href="../dev/python/holo.html"><strong aria-hidden="true">2.5.</strong> Holoviews</a></li><li class="chapter-item expanded "><a href="../dev/python/requirements.html"><strong aria-hidden="true">2.6.</strong> Requirements</a></li></ol></li><li class="chapter-item expanded "><a href="../dev/git.html"><strong aria-hidden="true">3.</strong> Git</a></li><li class="chapter-item expanded affix "><li class="part-title">Загружаем linux</li><li class="chapter-item expanded "><a href="../linux/intro.html"><strong aria-hidden="true">4.</strong> Основы Linux</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../linux/booting.html"><strong aria-hidden="true">4.1.</strong> Процесс загрузки</a></li><li class="chapter-item expanded "><a href="../linux/filesystems.html"><strong aria-hidden="true">4.2.</strong> Файловые системы</a></li><li class="chapter-item expanded "><a href="../linux/tools.html"><strong aria-hidden="true">4.3.</strong> Инструменты</a></li></ol></li><li class="chapter-item expanded "><a href="../linux/install-arch-linux.html"><strong aria-hidden="true">5.</strong> Установка Arch Linux</a></li><li class="chapter-item expanded "><a href="../linux/structure.html" class="active"><strong aria-hidden="true">6.</strong> Внутреннее устройство Linux</a></li><li class="chapter-item expanded affix "><li class="part-title">Учимся у других</li><li class="chapter-item expanded "><a href="../examples/intro.html"><strong aria-hidden="true">7.</strong> Коды и скрипты</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/kenv.html"><strong aria-hidden="true">7.1.</strong> Уравнение огибающей Капчинского-Владимирского для пучка заряженных частиц</a></li><li class="chapter-item expanded "><a href="../examples/redpic.html"><strong aria-hidden="true">7.2.</strong> Релятивистская разностная схема для расчета динамики частиц в сложных электрических и магнитных полях</a></li><li class="chapter-item expanded "><a href="../examples/envelope-optimize.html"><strong aria-hidden="true">7.3.</strong> Оптимизация огибающей пучка заряженных частиц с помощью генетического алгоритма</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Работаем самостоятельно</li><li class="chapter-item expanded "><a href="../practicum/review-code-task.html"><strong aria-hidden="true">8.</strong> Ищем ошибки в чужом коде</a></li><li class="chapter-item expanded "><a href="../practicum/markov-chain-task.html"><strong aria-hidden="true">9.</strong> Делаем свою LLM</a></li><li class="chapter-item expanded "><a href="../practicum/booting-linux-task.html"><strong aria-hidden="true">10.</strong> Установка Linux</a></li><li class="chapter-item expanded "><a href="../practicum/linux-tools-task.html"><strong aria-hidden="true">11.</strong> Набор упражнений для работы в Linux</a></li><li class="chapter-item expanded "><a href="../practicum/linux-structure-task.html"><strong aria-hidden="true">12.</strong> Маленькая задачка c Linux</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Разработка и применение программного обеспечения в физических исследованиях</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/phys-dev/book/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="Внутреннее-устройство-linux"><a class="header" href="#Внутреннее-устройство-linux">Внутреннее устройство Linux</a></h1>
<h2 id="Введение"><a class="header" href="#Введение">Введение</a></h2>
<h3 id="Почему-важно-изучать-внутреннее-устройство-linux"><a class="header" href="#Почему-важно-изучать-внутреннее-устройство-linux">Почему важно изучать внутреннее устройство Linux</a></h3>
<p><strong>Linux</strong> доминирует в современных IT-инфраструктурах:</p>
<ul>
<li>90% облачных инстансов работают на Linux</li>
<li>Все суперкомпьютеры из топ-500 используют Linux</li>
<li>Android (на базе Linux) - самая популярная мобильная ОС</li>
<li>Встроенные системы и IoT устройства в основном на Linux</li>
</ul>
<p><strong>Понимание внутренних механизмов</strong> позволяет:</p>
<ul>
<li><strong>Диагностировать сложные проблемы</strong> - от зависаний до утечек памяти</li>
<li><strong>Оптимизировать производительность</strong> - понимать, куда смотреть при нагрузке</li>
<li><strong>Писать эффективный код</strong> - знать стоимость системных вызовов</li>
<li><strong>Эффективно использовать облака</strong> - понимать, что происходит "под капотом"</li>
</ul>
<p><strong>Ключевой принцип</strong>: "Облака — это просто компьютеры в другом месте". Все те же процессы, память, сеть, но в удаленном дата-центре.</p>
<hr />
<h2 id="1-Зачем-изучать-linux"><a class="header" href="#1-Зачем-изучать-linux">1. Зачем изучать Linux?</a></h2>
<h3 id="Практическая-ценность-глубоких-знаний"><a class="header" href="#Практическая-ценность-глубоких-знаний">Практическая ценность глубоких знаний</a></h3>
<h4 id="Быстрая-диагностика-проблем"><a class="header" href="#Быстрая-диагностика-проблем">Быстрая диагностика проблем</a></h4>
<pre><code class="language-bash"># Вместо случайного тыкания
strace -p &lt;pid&gt;                    # что делает процесс?
perf record -g &lt;command&gt;          # где тратится время?
cat /proc/&lt;pid&gt;/status            # в каком состоянии?
</code></pre>
<p><strong>Пример из практики</strong>: Сервис периодически "зависал".
Анализ показал, что процесс переходил в состояние <code>D</code> (Uninterruptible sleep) при работе с NFS.
Решение: настройка таймаутов и retry-логики.</p>
<h4 id="Эффективное-программирование"><a class="header" href="#Эффективное-программирование">Эффективное программирование</a></h4>
<p>Знание стоимости операций:</p>
<ul>
<li>Системный вызов: ~1000 циклов CPU</li>
<li>Context switch: ~1000-10000 циклов</li>
<li>Page fault: ~10-100 микросекунд</li>
</ul>
<p><strong>Оптимизация</strong>: Сведение системных вызовов к минимуму, использование буферизации.</p>
<h4 id="Облачные-технологии"><a class="header" href="#Облачные-технологии">Облачные технологии</a></h4>
<p>Контейнеры, оркестрация, serverless - все построено на механизмах Linux:</p>
<ul>
<li><strong>Docker</strong> → cgroups + namespaces</li>
<li><strong>Kubernetes</strong> → управление процессами в масштабе</li>
<li><strong>AWS Lambda</strong> → изоляция и быстрый запуск</li>
</ul>
<hr />
<h2 id="2-Процессы"><a class="header" href="#2-Процессы">2. Процессы</a></h2>
<h3 id="Детальное-понимание-процессов"><a class="header" href="#Детальное-понимание-процессов">Детальное понимание процессов</a></h3>
<h4 id="Что-такое-процесс-на-самом-деле"><a class="header" href="#Что-такое-процесс-на-самом-деле">Что такое процесс на самом деле?</a></h4>
<p>Процесс - это не просто "запущенная программа", это <strong>контейнер выполнения</strong> с:</p>
<p><strong>Ресурсы</strong>:</p>
<ul>
<li>Виртуальное адресное пространство</li>
<li>Открытые файловые дескрипторы</li>
<li>Учетные данные и привилегии</li>
<li>Сигнальные маски и обработчики</li>
</ul>
<p><strong>Метаданные</strong>:</p>
<ul>
<li>PID, PPID, UID, GID</li>
<li>Приоритеты планирования</li>
<li>Состояние выполнения</li>
<li>Потребление ресурсов</li>
</ul>
<h4 id="Структура-процесса-в-ядре"><a class="header" href="#Структура-процесса-в-ядре">Структура процесса в ядре</a></h4>
<pre><code class="language-c">// Упрощенная task_struct (include/linux/sched.h)
struct task_struct {
    volatile long state;                    // состояние процесса
    void *stack;                           // указатель на стек
    struct mm_struct *mm;                  // память процесса
    struct files_struct *files;            // открытые файлы
    struct signal_struct *signal;          // сигналы
    // ... сотни полей
};
</code></pre>
<p><strong>Практическое использование</strong>:</p>
<pre><code class="language-bash"># Анализ конкретного процесса
ls -la /proc/1234/
cat /proc/1234/maps    # память процесса
cat /proc/1234/status  # состояние и лимиты
ls /proc/1234/fd/      # открытые файлы
</code></pre>
<h3 id="Создание-процессов-fork-и-exec"><a class="header" href="#Создание-процессов-fork-и-exec">Создание процессов: fork() и exec()</a></h3>
<h4 id="Механизм-copy-on-write-cow"><a class="header" href="#Механизм-copy-on-write-cow">Механизм Copy-on-Write (CoW)</a></h4>
<p><strong>До оптимизации</strong>:</p>
<ul>
<li><code>fork()</code> копировал всю память родителя</li>
<li>Очень дорогая операция для больших процессов</li>
</ul>
<p><strong>После CoW</strong>:</p>
<ul>
<li>Страницы памяти помечаются как read-only</li>
<li>Реальная копия происходит только при записи</li>
<li>Экономия памяти и времени</li>
</ul>
<pre><code class="language-c">pid_t pid = fork();
if (pid == 0) {
    // Дочерний процесс
    // Страницы памяти разделяются до первой записи
    execve("/bin/ls", args, env);
} else {
    // Родительский процесс
    waitpid(pid, &amp;status, 0);
}
</code></pre>
<h3 id="Потоки-threads-vs-Процессы"><a class="header" href="#Потоки-threads-vs-Процессы">Потоки (Threads) vs Процессы</a></h3>
<h4 id="Архитектурные-различия"><a class="header" href="#Архитектурные-различия">Архитектурные различия</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Аспект</th><th>Процесс</th><th>Поток</th></tr></thead><tbody>
<tr><td>Память</td><td>Изолированная</td><td>Разделяемая</td></tr>
<tr><td>Файлы</td><td>Отдельные таблицы</td><td>Общая таблица</td></tr>
<tr><td>Стоимость создания</td><td>Высокая</td><td>Низкая</td></tr>
<tr><td>Изоляция</td><td>Полная</td><td>Минимальная</td></tr>
</tbody></table>
</div>
<h4 id="Практические-сценарии-использования"><a class="header" href="#Практические-сценарии-использования">Практические сценарии использования</a></h4>
<p><strong>Используем процессы когда</strong>:</p>
<ul>
<li>Нужна изоляция отказоустойчивости</li>
<li>Работа с разными security-контекстами</li>
<li>Масштабирование на несколько машин</li>
</ul>
<p><strong>Используем потоки когда</strong>:</p>
<ul>
<li>Разделение состояния (кеш, соединения)</li>
<li>Низкая задержка взаимодействия</li>
<li>Эффективное использование CPU кэша</li>
</ul>
<h3 id="Межпроцессное-взаимодействие-ipc"><a class="header" href="#Межпроцессное-взаимодействие-ipc">Межпроцессное взаимодействие (IPC)</a></h3>
<h4 id="Сигналы---асинхронные-уведомления"><a class="header" href="#Сигналы---асинхронные-уведомления">Сигналы - асинхронные уведомления</a></h4>
<pre><code class="language-c">// Отправка сигнала
kill(pid, SIGTERM);

// Обработка сигнала
void handler(int sig) {
    // Асинхронно! Осторожно с shared state
}
signal(SIGTERM, handler);
</code></pre>
<p><strong>Важно</strong>: Большинство функций не являются signal-safe! Используйте только async-signal-safe функции в обработчиках.</p>
<h4 id="pipes---однонаправленная-коммуникация"><a class="header" href="#pipes---однонаправленная-коммуникация">Pipes - однонаправленная коммуникация</a></h4>
<pre><code class="language-bash"># Неименованные каналы
ls -la | grep ".txt" | wc -l

# Именованные каналы (FIFO)
mkfifo mypipe
echo "data" &gt; mypipe &amp;
cat mypipe
</code></pre>
<p><strong>Особенности</strong>:</p>
<ul>
<li>Буферизация на уровне ядра</li>
<li>Blocking I/O по умолчанию</li>
<li>Размер буфера можно настраивать</li>
</ul>
<h4 id="Разделяемая-память---максимальная-производительность"><a class="header" href="#Разделяемая-память---максимальная-производительность">Разделяемая память - максимальная производительность</a></h4>
<pre><code class="language-c">// Создание shared memory
int shm_id = shmget(key, size, IPC_CREAT | 0666);
void *ptr = shmat(shm_id, NULL, 0);

// Использование
memcpy(ptr, data, data_size);
</code></pre>
<p><strong>Преимущества</strong>:</p>
<ul>
<li>Нет копирования данных</li>
<li>Минимальная задержка</li>
<li>Прямой доступ к памяти</li>
</ul>
<p><strong>Недостатки</strong>:</p>
<ul>
<li>Сложная синхронизация</li>
<li>Риск состояния гонки</li>
</ul>
<h4 id="Семафоры---координация-доступа"><a class="header" href="#Семафоры---координация-доступа">Семафоры - координация доступа</a></h4>
<pre><code class="language-c">// Бинарный семафор (мьютекс)
sem_wait(&amp;mutex);
// Критическая секция
sem_post(&amp;mutex);
</code></pre>
<p><strong>Типы семафоров</strong>:</p>
<ul>
<li><strong>Binary</strong> (0 или 1) - для взаимного исключения</li>
<li><strong>Counting</strong> - для ограничения ресурсов</li>
</ul>
<h3 id="Состояния-процессов-полный-цикл-жизни"><a class="header" href="#Состояния-процессов-полный-цикл-жизни">Состояния процессов: полный цикл жизни</a></h3>
<h4 id="Детали-каждого-состояния"><a class="header" href="#Детали-каждого-состояния">Детали каждого состояния</a></h4>
<p><strong>R (Running/Runnable)</strong>:</p>
<ul>
<li>Процесс готов к выполнению или выполняется</li>
<li>Находится в runqueue планировщика</li>
<li>Может быть ограничен только доступностью CPU</li>
</ul>
<p><strong>S (Interruptible Sleep)</strong>:</p>
<ul>
<li>Ожидание события (I/O, семафор, сигнал)</li>
<li>Может быть прерван сигналом</li>
<li>Типичное состояние для I/O bound процессов</li>
</ul>
<p><strong>D (Uninterruptible Sleep)</strong>:</p>
<ul>
<li>Ожидание аппаратного I/O (диск, сеть)</li>
<li><strong>Не может быть прерван даже kill -9</strong></li>
<li>Опасное состояние - может привести к hung process</li>
</ul>
<p><strong>T (Stopped)</strong>:</p>
<ul>
<li>Приостановлен сигналом (SIGSTOP, SIGTSTP)</li>
<li>Может быть продолжен (SIGCONT)</li>
<li>Используется дебаггерами</li>
</ul>
<p><strong>Z (Zombie)</strong>:</p>
<ul>
<li>Процесс завершен, но родитель не забрал статус</li>
<li>Ресурсы освобождены, осталась только запись в таблице процессов</li>
<li><strong>Лечение</strong>: завершить родительский процесс</li>
</ul>
<h4 id="Практический-мониторинг"><a class="header" href="#Практический-мониторинг">Практический мониторинг</a></h4>
<pre><code class="language-bash"># Понимание состояния процессов
ps aux | awk '{print $8}' | sort | uniq -c

# Поиск проблемных процессов
# Процессы в D состоянии
ps aux | awk '$8=="D" {print $0}'

# Zombie процессы
ps aux | awk '$8=="Z" {print $0}'
</code></pre>
<hr />
<h2 id="3-Планировщик-scheduler"><a class="header" href="#3-Планировщик-scheduler">3. Планировщик (Scheduler)</a></h2>
<h3 id="Эволюция-планировщиков-linux"><a class="header" href="#Эволюция-планировщиков-linux">Эволюция планировщиков Linux</a></h3>
<h4 id="on-планировщик-до-24"><a class="header" href="#on-планировщик-до-24">O(N) планировщик (до 2.4)</a></h4>
<pre><code class="language-c">// Псевдокод старого планировщика
for (each task in system) {
    calculate_goodness(task);
    if (goodness &gt; max_goodness) {
        next_task = task;
        max_goodness = goodness;
    }
}
</code></pre>
<p><strong>Проблемы</strong>: O(N) сложность, не масштабировался на многоядерные системы</p>
<h4 id="o1-планировщик-260---2622"><a class="header" href="#o1-планировщик-260---2622">O(1) планировщик (2.6.0 - 2.6.22)</a></h4>
<ul>
<li>Две очереди: active и expired</li>
<li>Bitmap для быстрого поиска</li>
<li>Константное время планирования</li>
</ul>
<p><strong>Достижения</strong>: Хорошая масштабируемость, поддержка SMP</p>
<h4 id="cfs-completely-fair-scheduler-2623"><a class="header" href="#cfs-completely-fair-scheduler-2623">CFS (Completely Fair Scheduler) (2.6.23+)</a></h4>
<pre><code class="language-c">// Основан на красно-черных деревьях
struct rb_root_cached {
    struct rb_root rb_root;
    struct rb_node *rb_leftmost;
};
</code></pre>
<p><strong>Философия</strong>: "Справедливое" распределение CPU времени</p>
<h3 id="Приоритеты-и-политики-планирования"><a class="header" href="#Приоритеты-и-политики-планирования">Приоритеты и политики планирования</a></h3>
<h4 id="real-time-политики"><a class="header" href="#real-time-политики">Real-Time политики</a></h4>
<p><strong>SCHED_FIFO (First-In-First-Out)</strong>:</p>
<ul>
<li>Бесконечный time slice</li>
<li>Вытесняется только более приоритетным RT процессом</li>
<li><strong>Опасность</strong>: может занять CPU навсегда</li>
</ul>
<p><strong>SCHED_RR (Round Robin)</strong>:</p>
<ul>
<li>Фиксированный time slice (100ms по умолчанию)</li>
<li>Циклическое переключение между процессами одинакового приоритета</li>
<li>Более безопасен чем FIFO</li>
</ul>
<h4 id="normal-политики"><a class="header" href="#normal-политики">Normal политики</a></h4>
<p><strong>SCHED_NORMAL/OTHER</strong>:</p>
<ul>
<li>Динамические приоритеты (nice значения)</li>
<li>Интерактивные процессы получают "бонус"</li>
<li>Фоновые процессы слегка "штрафуются"</li>
</ul>
<h4 id="nice-значения-и-приоритеты"><a class="header" href="#nice-значения-и-приоритеты">Nice значения и приоритеты</a></h4>
<pre><code class="language-bash"># Установка nice значения
nice -n 10 ./long_running_task    # низкий приоритет
nice -n -20 ./critical_task       # высокий приоритет

# Изменение running процесса
renice -n 5 -p 1234
</code></pre>
<p><strong>Диапазон</strong>: -20 (высший) до +19 (низший)</p>
<h3 id="cfs-внутреннее-устройство"><a class="header" href="#cfs-внутреннее-устройство">CFS: внутреннее устройство</a></h3>
<h4 id="Ключевые-концепции"><a class="header" href="#Ключевые-концепции">Ключевые концепции</a></h4>
<p><strong>Virtual Runtime (vruntime)</strong>:</p>
<ul>
<li>Время выполнения, нормализованное по приоритету</li>
<li>Процессы с меньшим vruntime выполняются первыми</li>
<li>Nice значения влияют на скорость накопления vruntime</li>
</ul>
<p><strong>Target Latency</strong>:</p>
<ul>
<li>Время, за которое все runnable процессы должны выполниться</li>
<li>По умолчанию: 6ms для desktop, 24ms для server</li>
</ul>
<p><strong>Minimal Granularity</strong>:</p>
<ul>
<li>Минимальное время выполнения перед вытеснением</li>
<li>0.75ms для предотвращения частого переключения</li>
</ul>
<h4 id="Реализация-на-красно-черных-деревьях"><a class="header" href="#Реализация-на-красно-черных-деревьях">Реализация на красно-черных деревьях</a></h4>
<pre><code class="language-c">// Вставка процесса в дерево
struct sched_entity {
    struct rb_node run_node;
    u64 vruntime;
    // ...
};

// Быстрый поиск процесса с минимальным vruntime
struct task_struct *pick_next_task(struct rq *rq) {
    struct rb_node *left = rb_first_cached(&amp;rq-&gt;tasks_timeline);
    return rb_entry(left, struct task_struct, se.run_node);
}
</code></pre>
<p><strong>Преимущества</strong>: O(log N) для вставки/удаления</p>
<h3 id="Управление-планировщиком-на-практике"><a class="header" href="#Управление-планировщиком-на-практике">Управление планировщиком на практике</a></h3>
<h4 id="cpu-affinity"><a class="header" href="#cpu-affinity">CPU Affinity</a></h4>
<pre><code class="language-bash"># Привязка процесса к конкретным ядрам
taskset -c 0,1 ./application

# Просмотр текущей маски
taskset -p 1234

# Запуск с распределением по ядрам
numactl --cpunodebind=0,1 --membind=0,1 ./app
</code></pre>
<p><strong>Сценарии использования</strong>:</p>
<ul>
<li>Изоляция критичных процессов</li>
<li>Улучшение locality кэша</li>
<li>NUMA-оптимизация</li>
</ul>
<h4 id="Настройка-планировщика"><a class="header" href="#Настройка-планировщика">Настройка планировщика</a></h4>
<pre><code class="language-bash"># Просмотр параметров
cat /proc/sys/kernel/sched_min_granularity_ns
cat /proc/sys/kernel/sched_latency_ns

# Изменение параметров
echo 10000000 &gt; /proc/sys/kernel/sched_latency_ns
</code></pre>
<h4 id="Мониторинг-планировщика"><a class="header" href="#Мониторинг-планировщика">Мониторинг планировщика</a></h4>
<pre><code class="language-bash"># Статистика переключений
cat /proc/1234/sched

# Очереди выполнения
cat /proc/sched_debug

# Профилирование
perf sched record ./application
perf sched latency
</code></pre>
<hr />
<h2 id="4-Прерывания"><a class="header" href="#4-Прерывания">4. Прерывания</a></h2>
<h3 id="Архитектура-прерываний-в-x86x64"><a class="header" href="#Архитектура-прерываний-в-x86x64">Архитектура прерываний в x86/x64</a></h3>
<h4 id="Аппаратные-прерывания-irqs"><a class="header" href="#Аппаратные-прерывания-irqs">Аппаратные прерывания (IRQs)</a></h4>
<p><strong>Источники</strong>:</p>
<ul>
<li>Таймеры</li>
<li>Сетевые карты</li>
<li>Дисковые контроллеры</li>
<li>USB устройства</li>
</ul>
<p><strong>Механизм</strong>:</p>
<pre><code class="language-c">// Регистрация обработчика
request_irq(IRQ_NUMBER, handler, flags, name, dev);

// Обработчик прерывания
static irqreturn_t my_handler(int irq, void *dev_id) {
    // Быстрая обработка
    return IRQ_HANDLED;
}
</code></pre>
<h4 id="Исключения-процессора"><a class="header" href="#Исключения-процессора">Исключения процессора</a></h4>
<p><strong>Типы</strong>:</p>
<ul>
<li><strong>Faults</strong> - исправимые (page fault)</li>
<li><strong>Traps</strong> - преднамеренные (breakpoints)</li>
<li><strong>Aborts</strong> - фатальные ошибки</li>
</ul>
<h3 id="Обработка-прерываний-upper-и-bottom-halves"><a class="header" href="#Обработка-прерываний-upper-и-bottom-halves">Обработка прерываний: Upper и Bottom Halves</a></h3>
<h4 id="upper-half-Верхняя-половина"><a class="header" href="#upper-half-Верхняя-половина">Upper Half (Верхняя половина)</a></h4>
<p><strong>Требования</strong>:</p>
<ul>
<li>Максимально быстрое выполнение</li>
<li>Минимальная работа</li>
<li>Без блокирующих операций</li>
</ul>
<pre><code class="language-c">// Типичный upper half
irqreturn_t eth_interrupt(int irq, void *dev_id) {
    struct net_device *dev = dev_id;
    disable_irq_nosync(dev-&gt;irq);
    schedule_work(&amp;dev-&gt;tx_work);
    return IRQ_HANDLED;
}
</code></pre>
<h4 id="bottom-half-Нижняя-половина"><a class="header" href="#bottom-half-Нижняя-половина">Bottom Half (Нижняя половина)</a></h4>
<p><strong>Механизмы</strong>:</p>
<ol>
<li>
<p><strong>SoftIRQs</strong>:</p>
<ul>
<li>Статические в ядре (сеть, блокирующие устройства)</li>
<li>Очень быстрые, но сложные в использовании</li>
</ul>
</li>
<li>
<p><strong>Tasklets</strong>:</p>
<ul>
<li>Динамические, atomic scheduling</li>
<li>Не могут выполняться параллельно</li>
</ul>
</li>
<li>
<p><strong>Work Queues</strong>:</p>
<ul>
<li>Выполняются в контексте процесса</li>
<li>Могут sleep и использовать блокирующие вызовы</li>
</ul>
</li>
</ol>
<pre><code class="language-c">// Work queue пример
DECLARE_WORK(my_work, my_work_function);

void my_work_function(struct work_struct *work) {
    // Медленная обработка
    process_packets();
    enable_irq(dev-&gt;irq);
}
</code></pre>
<h3 id="Практическая-работа-с-прерываниями"><a class="header" href="#Практическая-работа-с-прерываниями">Практическая работа с прерываниями</a></h3>
<h4 id="Мониторинг-прерываний"><a class="header" href="#Мониторинг-прерываний">Мониторинг прерываний</a></h4>
<pre><code class="language-bash"># Статистика прерываний
cat /proc/interrupts

# Распределение прерываний по CPU
cat /proc/irq/*/smp_affinity

# Изменение привязки прерываний
echo 2 &gt; /proc/irq/24/smp_affinity
</code></pre>
<h4 id="Оптимизация-обработки"><a class="header" href="#Оптимизация-обработки">Оптимизация обработки</a></h4>
<p><strong>Techniques</strong>:</p>
<ul>
<li>Balance IRQs across CPUs</li>
<li>Use MSI instead of legacy interrupts</li>
<li>Tune network queue sizes</li>
<li>Adjust IRQ coalescing settings</li>
</ul>
<hr />
<h2 id="5-Системные-вызовы"><a class="header" href="#5-Системные-вызовы">5. Системные вызовы</a></h2>
<h3 id="Механизм-системных-вызовов"><a class="header" href="#Механизм-системных-вызовов">Механизм системных вызовов</a></h3>
<h4 id="Переключение-между-пространствами"><a class="header" href="#Переключение-между-пространствами">Переключение между пространствами</a></h4>
<p><strong>Пользовательское пространство</strong> → <strong>Пространство ядра</strong>:</p>
<pre><code class="language-assembly">; x86-64 системный вызов
mov rax, 1      ; номер syscall (write)
mov rdi, 1      ; fd (stdout)
mov rsi, buffer ; буфер
mov rdx, count  ; размер
syscall         ; переход в ядро
</code></pre>
<p><strong>Процесс переключения</strong>:</p>
<ol>
<li>Сохранение контекста пользователя</li>
<li>Переход в режим ядра</li>
<li>Валидация параметров</li>
<li>Выполнение операции</li>
<li>Возврат результата</li>
<li>Восстановление контекста</li>
</ol>
<h4 id="Таблица-системных-вызовов"><a class="header" href="#Таблица-системных-вызовов">Таблица системных вызовов</a></h4>
<pre><code class="language-c">// Определение syscall (kernel/sys.c)
SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf,
                size_t, count)
{
    struct fd f = fdget_pos(fd);
    // ... обработка
    return ret;
}
</code></pre>
<p><strong>Важно</strong>: Все параметры проверяются на валидность!</p>
<h3 id="Безопасность-системных-вызовов"><a class="header" href="#Безопасность-системных-вызовов">Безопасность системных вызовов</a></h3>
<h4 id="Проверки-доступа"><a class="header" href="#Проверки-доступа">Проверки доступа</a></h4>
<pre><code class="language-c">// Проверка указателей из userspace
if (copy_from_user(kernel_buf, user_buf, size))
    return -EFAULT;

// Проверка прав доступа
if (!file_permission(file, MAY_READ))
    return -EPERM;
</code></pre>
<h4 id="capabilities-based-security"><a class="header" href="#capabilities-based-security">Capabilities-based security</a></h4>
<pre><code class="language-c">// Вместо проверки UID == 0
if (!capable(CAP_SYS_ADMIN))
    return -EPERM;
</code></pre>
<h3 id="Производительность-системных-вызовов"><a class="header" href="#Производительность-системных-вызовов">Производительность системных вызовов</a></h3>
<h4 id="Измерение-стоимости"><a class="header" href="#Измерение-стоимости">Измерение стоимости</a></h4>
<pre><code class="language-c">#include &lt;sys/time.h&gt;

struct timeval start, end;
gettimeofday(&amp;start, NULL);
// системный вызов
gettimeofday(&amp;end, NULL);

long microseconds = (end.tv_sec - start.tv_sec) * 1000000 
                  + (end.tv_usec - start.tv_usec);
</code></pre>
<p><strong>Типичные затраты</strong>:</p>
<ul>
<li>Простой syscall: 0.1 - 1 микросекунда</li>
<li>I/O syscalls: 1 - 1000 микросекунд</li>
<li>Context switch: 1 - 10 микросекунд</li>
</ul>
<h4 id="Оптимизация"><a class="header" href="#Оптимизация">Оптимизация</a></h4>
<p><strong>Методы</strong>:</p>
<ul>
<li>Batch operations (writev вместо множества write)</li>
<li>Memory mapping (mmap вместо read/write)</li>
<li>Avoid unnecessary syscalls</li>
<li>Use vDSO для частых вызовов (gettimeofday)</li>
</ul>
<hr />
<h2 id="6-Память-процесса"><a class="header" href="#6-Память-процесса">6. Память процесса</a></h2>
<h3 id="Виртуальная-память-полная-картина"><a class="header" href="#Виртуальная-память-полная-картина">Виртуальная память: полная картина</a></h3>
<h4 id="Макет-адресного-пространства"><a class="header" href="#Макет-адресного-пространства">Макет адресного пространства</a></h4>
<pre><code>0x0000000000000000 ┌─────────────────┐
                   │    Зарезервировано   │
                   │   (NULL-ptr guard)  │
0x0000000000400000 ├─────────────────┤
                   │       Text        │
                   │  (код программы)  │
0x0000000000600000 ├─────────────────┤
                   │     Data (init)    │
                   │ (инициализированные)│
0x0000000000601000 ├─────────────────┤
                   │    BSS (uninit)    │
                   │ (неинициализированные)│
0x0000000000800000 ├─────────────────┤
                   │        Heap        │
                   │   (динамическая)   │
                   │        ↓           │
0x00007ffff0000000 ├─────────────────┤
                   │     MMAP region    │
                   │   (библиотеки,     │
                   │    shared mem)     │
0x00007ffff7a00000 ├─────────────────┤
                   │       Stack        │
                   │   (автоматические) │
                   │        ↑           │
0x00007ffffff00000 ├─────────────────┤
                   │   Kernel space     │
                   │  (недоступно)      │
0xffffffffffffffff └─────────────────┘
</code></pre>
<h3 id="Управление-памятью-на-практике"><a class="header" href="#Управление-памятью-на-практике">Управление памятью на практике</a></h3>
<h4 id="Анализ-памяти-процесса"><a class="header" href="#Анализ-памяти-процесса">Анализ памяти процесса</a></h4>
<pre><code class="language-bash"># Детальная информация о памяти
pmap -XX 1234

# Статистика памяти
cat /proc/1234/smaps

# Page faults
ps -o min_flt,maj_flt,cmd -p 1234
</code></pre>
<h4 id="Типы-page-faults"><a class="header" href="#Типы-page-faults">Типы page faults</a></h4>
<p><strong>Minor Fault</strong>:</p>
<ul>
<li>Страница в физической памяти</li>
<li>Но не отображена в page tables процесса</li>
<li>Быстрое разрешение</li>
</ul>
<p><strong>Major Fault</strong>:</p>
<ul>
<li>Страница не в физической памяти</li>
<li>Требуется загрузка с диска</li>
<li>Медленное разрешение</li>
</ul>
<h3 id="Проблемы-с-памятью-и-решения"><a class="header" href="#Проблемы-с-памятью-и-решения">Проблемы с памятью и решения</a></h3>
<h4 id="out-of-memory-oom"><a class="header" href="#out-of-memory-oom">Out of Memory (OOM)</a></h4>
<p><strong>Механизм OOM killer</strong>:</p>
<ol>
<li>Ядро обнаруживает нехватку памяти</li>
<li>Вычисляет "badness score" для каждого процесса</li>
<li>Выбирает и завершает процесс с максимальным score</li>
</ol>
<p><strong>Управление OOM</strong>:</p>
<pre><code class="language-bash"># Настройка политики OOM
echo -1000 &gt; /proc/1234/oom_score_adj    # защитить процесс
echo 1000 &gt; /proc/1234/oom_score_adj     # первым кандидат

# Ручной вызов OOM killer
echo f &gt; /proc/sysrq-trigger
</code></pre>
<h4 id="swap-управление"><a class="header" href="#swap-управление">SWAP управление</a></h4>
<pre><code class="language-bash"># Мониторинг swap
swapon --show
free -h

# Настройка swappiness
echo 10 &gt; /proc/sys/vm/swappiness    # меньше swap (сервер)
echo 60 &gt; /proc/sys/vm/swappiness    # больше swap (десктоп)
</code></pre>
<h4 id="numa-оптимизация"><a class="header" href="#numa-оптимизация">NUMA оптимизация</a></h4>
<pre><code class="language-bash"># Информация о NUMA
numactl --hardware

# Запуск с учетом NUMA
numactl --membind=0 --cpunodebind=0 ./application

# Статистика NUMA
cat /proc/1234/numa_maps
</code></pre>
<hr />
<h2 id="7-Изоляция"><a class="header" href="#7-Изоляция">7. Изоляция</a></h2>
<h3 id="Эволюция-изоляции-в-linux"><a class="header" href="#Эволюция-изоляции-в-linux">Эволюция изоляции в Linux</a></h3>
<h4 id="От-chroot-до-контейнеров"><a class="header" href="#От-chroot-до-контейнеров">От chroot до контейнеров</a></h4>
<p><strong>Историческое развитие</strong>:</p>
<ul>
<li>1979: chroot в UNIX</li>
<li>2000: FreeBSD Jails</li>
<li>2001: Linux-VServer</li>
<li>2004: Solaris Zones</li>
<li>2008: LXC (Linux Containers)</li>
<li>2013: Docker</li>
<li>2014: Kubernetes</li>
</ul>
<h3 id="cgroups-управление-ресурсами"><a class="header" href="#cgroups-управление-ресурсами">Cgroups: управление ресурсами</a></h3>
<h4 id="Иерархия-cgroups-v2"><a class="header" href="#Иерархия-cgroups-v2">Иерархия cgroups v2</a></h4>
<pre><code>/sys/fs/cgroup/
├── system.slice/          # системные службы
│   ├── ssh.service
│   └── docker.service
├── user.slice/            # пользовательские процессы
│   ├── user-1000.slice
│   └── user-1001.slice
├── kubepods.slice/        # Kubernetes pods
│   ├── pod1/
│   └── pod2/
└── cgroup.controllers     # доступные контроллеры
</code></pre>
<h4 id="Контроллеры-ресурсов"><a class="header" href="#Контроллеры-ресурсов">Контроллеры ресурсов</a></h4>
<p><strong>CPU</strong>:</p>
<pre><code class="language-bash"># Ограничение CPU
echo "200000 1000000" &gt; /sys/fs/cgroup/mygroup/cpu.max
# 200ms из каждых 1000ms

# CPU shares
echo 512 &gt; /sys/fs/cgroup/mygroup/cpu.weight
</code></pre>
<p><strong>Память</strong>:</p>
<pre><code class="language-bash"># Лимит памяти
echo 1G &gt; /sys/fs/cgroup/mygroup/memory.max

# SWAP лимит
echo 2G &gt; /sys/fs/cgroup/mygroup/memory.swap.max

# OOM политика
echo "oom_group" &gt; /sys/fs/cgroup/mygroup/memory.oom.group
</code></pre>
<p><strong>I/O</strong>:</p>
<pre><code class="language-bash"># Ограничение дискового I/O
echo "8:0 rbps=1048576 wbps=1048576" &gt; /sys/fs/cgroup/mygroup/io.max
</code></pre>
<h3 id="namespaces-изоляция-представлений"><a class="header" href="#namespaces-изоляция-представлений">Namespaces: изоляция представлений</a></h3>
<h4 id="Типы-namespaces"><a class="header" href="#Типы-namespaces">Типы namespaces</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Namespace</th><th>Изолирует</th><th>Команда</th></tr></thead><tbody>
<tr><td>PID</td><td>Process IDs</td><td>unshare --pid</td></tr>
<tr><td>Network</td><td>Network stack</td><td>unshare --net</td></tr>
<tr><td>Mount</td><td>Filesystem mounts</td><td>unshare --mount</td></tr>
<tr><td>UTS</td><td>Hostname, domain</td><td>unshare --uts</td></tr>
<tr><td>IPC</td><td>System V IPC</td><td>unshare --ipc</td></tr>
<tr><td>User</td><td>User/group IDs</td><td>unshare --user</td></tr>
<tr><td>Cgroup</td><td>Cgroup hierarchy</td><td>unshare --cgroup</td></tr>
<tr><td>Time</td><td>System time</td><td>unshare --time</td></tr>
</tbody></table>
</div>
<h4 id="Практическое-использование-namespaces"><a class="header" href="#Практическое-использование-namespaces">Практическое использование namespaces</a></h4>
<p><strong>Создание изолированного окружения</strong>:</p>
<pre><code class="language-bash"># Создание namespace и запуск процесса
sudo unshare --fork --pid --mount-proc bash

# В новом namespace:
ps aux    # видит только свои процессы
mount     # видит только свои mount points
</code></pre>
<p><strong>Docker-подобный контейнер вручную</strong>:</p>
<pre><code class="language-bash"># Создание root filesystem
mkdir /mycontainer
debootstrap stable /mycontainer

# Запуск в изоляции
unshare --fork --pid --mount-proc --net --uts chroot /mycontainer /bin/bash

# В контейнере:
hostname mycontainer
ip link set lo up
</code></pre>
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Понимание внутреннего устройства Linux - это не академическое знание, а практический инструмент для создания надежных, производительных и безопасных систем.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linux/install-arch-linux.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../examples/intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linux/install-arch-linux.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../examples/intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
